// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_PROCESSORINFO_COM_EOLWRAL_OSMONITOR_CORE_H_
#define FLATBUFFERS_GENERATED_PROCESSORINFO_COM_EOLWRAL_OSMONITOR_CORE_H_

#include "flatbuffers/flatbuffers.h"


namespace com {
namespace eolwral {
namespace osmonitor {
namespace core {

struct processorInfo;
struct processorInfoList;

struct processorInfo : private flatbuffers::Table {
  /// Maximum Frequency 
  uint32_t maxFrequency() const { return GetField<uint32_t>(4, 0); }
  /// Minimum Frequency 
  uint32_t minFrequency() const { return GetField<uint32_t>(6, 0); }
  /// Maximum Scaling Frequency 
  uint32_t maxScaling() const { return GetField<uint32_t>(8, 0); }
  /// Minimum Scaling Frequency 
  uint32_t minScaling() const { return GetField<uint32_t>(10, 0); }
  /// Current Scaling Frequency 
  uint32_t currentScaling() const { return GetField<uint32_t>(12, 0); }
  /// Current Governors 
  const flatbuffers::String *governors() const { return GetPointer<const flatbuffers::String *>(14); }
  /// Number 
  uint32_t number() const { return GetField<uint32_t>(16, 0); }
  /// Off-line 
  uint8_t offLine() const { return GetField<uint8_t>(18, 0); }
  /// Available Grovernors 
  const flatbuffers::String *availableGovernors() const { return GetPointer<const flatbuffers::String *>(20); }
  /// Available Frequency 
  const flatbuffers::String *availableFrequency() const { return GetPointer<const flatbuffers::String *>(22); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* maxFrequency */) &&
           VerifyField<uint32_t>(verifier, 6 /* minFrequency */) &&
           VerifyField<uint32_t>(verifier, 8 /* maxScaling */) &&
           VerifyField<uint32_t>(verifier, 10 /* minScaling */) &&
           VerifyField<uint32_t>(verifier, 12 /* currentScaling */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* governors */) &&
           verifier.Verify(governors()) &&
           VerifyField<uint32_t>(verifier, 16 /* number */) &&
           VerifyField<uint8_t>(verifier, 18 /* offLine */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 20 /* availableGovernors */) &&
           verifier.Verify(availableGovernors()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 22 /* availableFrequency */) &&
           verifier.Verify(availableFrequency()) &&
           verifier.EndTable();
  }
};

struct processorInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maxFrequency(uint32_t maxFrequency) { fbb_.AddElement<uint32_t>(4, maxFrequency, 0); }
  void add_minFrequency(uint32_t minFrequency) { fbb_.AddElement<uint32_t>(6, minFrequency, 0); }
  void add_maxScaling(uint32_t maxScaling) { fbb_.AddElement<uint32_t>(8, maxScaling, 0); }
  void add_minScaling(uint32_t minScaling) { fbb_.AddElement<uint32_t>(10, minScaling, 0); }
  void add_currentScaling(uint32_t currentScaling) { fbb_.AddElement<uint32_t>(12, currentScaling, 0); }
  void add_governors(flatbuffers::Offset<flatbuffers::String> governors) { fbb_.AddOffset(14, governors); }
  void add_number(uint32_t number) { fbb_.AddElement<uint32_t>(16, number, 0); }
  void add_offLine(uint8_t offLine) { fbb_.AddElement<uint8_t>(18, offLine, 0); }
  void add_availableGovernors(flatbuffers::Offset<flatbuffers::String> availableGovernors) { fbb_.AddOffset(20, availableGovernors); }
  void add_availableFrequency(flatbuffers::Offset<flatbuffers::String> availableFrequency) { fbb_.AddOffset(22, availableFrequency); }
  processorInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  processorInfoBuilder &operator=(const processorInfoBuilder &);
  flatbuffers::Offset<processorInfo> Finish() {
    auto o = flatbuffers::Offset<processorInfo>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<processorInfo> CreateprocessorInfo(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t maxFrequency = 0,
   uint32_t minFrequency = 0,
   uint32_t maxScaling = 0,
   uint32_t minScaling = 0,
   uint32_t currentScaling = 0,
   flatbuffers::Offset<flatbuffers::String> governors = 0,
   uint32_t number = 0,
   uint8_t offLine = 0,
   flatbuffers::Offset<flatbuffers::String> availableGovernors = 0,
   flatbuffers::Offset<flatbuffers::String> availableFrequency = 0) {
  processorInfoBuilder builder_(_fbb);
  builder_.add_availableFrequency(availableFrequency);
  builder_.add_availableGovernors(availableGovernors);
  builder_.add_number(number);
  builder_.add_governors(governors);
  builder_.add_currentScaling(currentScaling);
  builder_.add_minScaling(minScaling);
  builder_.add_maxScaling(maxScaling);
  builder_.add_minFrequency(minFrequency);
  builder_.add_maxFrequency(maxFrequency);
  builder_.add_offLine(offLine);
  return builder_.Finish();
}

struct processorInfoList : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<processorInfo>> *list() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<processorInfo>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* list */) &&
           verifier.Verify(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
};

struct processorInfoListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<processorInfo>>> list) { fbb_.AddOffset(4, list); }
  processorInfoListBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  processorInfoListBuilder &operator=(const processorInfoListBuilder &);
  flatbuffers::Offset<processorInfoList> Finish() {
    auto o = flatbuffers::Offset<processorInfoList>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<processorInfoList> CreateprocessorInfoList(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<processorInfo>>> list = 0) {
  processorInfoListBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline const processorInfoList *GetprocessorInfoList(const void *buf) { return flatbuffers::GetRoot<processorInfoList>(buf); }

inline bool VerifyprocessorInfoListBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<processorInfoList>(); }

inline void FinishprocessorInfoListBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<processorInfoList> root) { fbb.Finish(root); }

}  // namespace core
}  // namespace osmonitor
}  // namespace eolwral
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_PROCESSORINFO_COM_EOLWRAL_OSMONITOR_CORE_H_
