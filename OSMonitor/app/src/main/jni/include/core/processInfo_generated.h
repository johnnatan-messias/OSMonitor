// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_PROCESSINFO_COM_EOLWRAL_OSMONITOR_CORE_H_
#define FLATBUFFERS_GENERATED_PROCESSINFO_COM_EOLWRAL_OSMONITOR_CORE_H_

#include "flatbuffers/flatbuffers.h"


namespace com {
namespace eolwral {
namespace osmonitor {
namespace core {

struct processInfo;
struct processInfoList;

enum processStatus {
  /// process status is unknown 
  processStatus_Unknown = 0,
  /// process is running 
  processStatus_Running = 1,
  /// process is s sleeping in an interruptible wait 
  processStatus_Sleep = 2,
  /// process is traced or stopped 
  processStatus_Stopped = 3,
  /// process is is waiting in uninterruptible disk sleep 
  processStatus_Disk = 4,
  /// process is zombie that couldn't be killed 
  processStatus_Zombie = 5,
  /// process is paging 
  processStatus_Page = 6
};

inline const char **EnumNamesprocessStatus() {
  static const char *names[] = { "Unknown", "Running", "Sleep", "Stopped", "Disk", "Zombie", "Page", nullptr };
  return names;
}

inline const char *EnumNameprocessStatus(processStatus e) { return EnumNamesprocessStatus()[e]; }

struct processInfo : private flatbuffers::Table {
  /// process name 
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  /// process owner 
  const flatbuffers::String *owner() const { return GetPointer<const flatbuffers::String *>(6); }
  /// process status 
  processStatus status() const { return static_cast<processStatus>(GetField<int8_t>(8, 0)); }
  /// process uid 
  uint32_t uid() const { return GetField<uint32_t>(10, 0); }
  /// process pid 
  uint32_t pid() const { return GetField<uint32_t>(12, 0); }
  /// process pid for parent 
  uint32_t ppid() const { return GetField<uint32_t>(14, 0); }
  /// resident set size 
  uint64_t rss() const { return GetField<uint64_t>(16, 0); }
  /// virtual size 
  uint64_t vsz() const { return GetField<uint64_t>(18, 0); }
  /// CPU usage 
  float cpuUsage() const { return GetField<float>(20, 0); }
  /// thread count for this process 
  uint32_t threadCount() const { return GetField<uint32_t>(22, 0); }
  /// priority from -20 to 20 
  uint32_t priorityLevel() const { return GetField<uint32_t>(24, 0); }
  /// used user time (user mode) 
  uint64_t usedUserTime() const { return GetField<uint64_t>(26, 0); }
  /// used system time (kernel mode) 
  uint64_t usedSystemTime() const { return GetField<uint64_t>(28, 0); }
  /// start time 
  uint64_t startTime() const { return GetField<uint64_t>(30, 0); }
  /// CPU time 
  uint64_t cpuTime() const { return GetField<uint64_t>(32, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* owner */) &&
           verifier.Verify(owner()) &&
           VerifyField<int8_t>(verifier, 8 /* status */) &&
           VerifyField<uint32_t>(verifier, 10 /* uid */) &&
           VerifyField<uint32_t>(verifier, 12 /* pid */) &&
           VerifyField<uint32_t>(verifier, 14 /* ppid */) &&
           VerifyField<uint64_t>(verifier, 16 /* rss */) &&
           VerifyField<uint64_t>(verifier, 18 /* vsz */) &&
           VerifyField<float>(verifier, 20 /* cpuUsage */) &&
           VerifyField<uint32_t>(verifier, 22 /* threadCount */) &&
           VerifyField<uint32_t>(verifier, 24 /* priorityLevel */) &&
           VerifyField<uint64_t>(verifier, 26 /* usedUserTime */) &&
           VerifyField<uint64_t>(verifier, 28 /* usedSystemTime */) &&
           VerifyField<uint64_t>(verifier, 30 /* startTime */) &&
           VerifyField<uint64_t>(verifier, 32 /* cpuTime */) &&
           verifier.EndTable();
  }
};

struct processInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_owner(flatbuffers::Offset<flatbuffers::String> owner) { fbb_.AddOffset(6, owner); }
  void add_status(processStatus status) { fbb_.AddElement<int8_t>(8, static_cast<int8_t>(status), 0); }
  void add_uid(uint32_t uid) { fbb_.AddElement<uint32_t>(10, uid, 0); }
  void add_pid(uint32_t pid) { fbb_.AddElement<uint32_t>(12, pid, 0); }
  void add_ppid(uint32_t ppid) { fbb_.AddElement<uint32_t>(14, ppid, 0); }
  void add_rss(uint64_t rss) { fbb_.AddElement<uint64_t>(16, rss, 0); }
  void add_vsz(uint64_t vsz) { fbb_.AddElement<uint64_t>(18, vsz, 0); }
  void add_cpuUsage(float cpuUsage) { fbb_.AddElement<float>(20, cpuUsage, 0); }
  void add_threadCount(uint32_t threadCount) { fbb_.AddElement<uint32_t>(22, threadCount, 0); }
  void add_priorityLevel(uint32_t priorityLevel) { fbb_.AddElement<uint32_t>(24, priorityLevel, 0); }
  void add_usedUserTime(uint64_t usedUserTime) { fbb_.AddElement<uint64_t>(26, usedUserTime, 0); }
  void add_usedSystemTime(uint64_t usedSystemTime) { fbb_.AddElement<uint64_t>(28, usedSystemTime, 0); }
  void add_startTime(uint64_t startTime) { fbb_.AddElement<uint64_t>(30, startTime, 0); }
  void add_cpuTime(uint64_t cpuTime) { fbb_.AddElement<uint64_t>(32, cpuTime, 0); }
  processInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  processInfoBuilder &operator=(const processInfoBuilder &);
  flatbuffers::Offset<processInfo> Finish() {
    auto o = flatbuffers::Offset<processInfo>(fbb_.EndTable(start_, 15));
    return o;
  }
};

inline flatbuffers::Offset<processInfo> CreateprocessInfo(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::String> owner = 0,
   processStatus status = processStatus_Unknown,
   uint32_t uid = 0,
   uint32_t pid = 0,
   uint32_t ppid = 0,
   uint64_t rss = 0,
   uint64_t vsz = 0,
   float cpuUsage = 0,
   uint32_t threadCount = 0,
   uint32_t priorityLevel = 0,
   uint64_t usedUserTime = 0,
   uint64_t usedSystemTime = 0,
   uint64_t startTime = 0,
   uint64_t cpuTime = 0) {
  processInfoBuilder builder_(_fbb);
  builder_.add_cpuTime(cpuTime);
  builder_.add_startTime(startTime);
  builder_.add_usedSystemTime(usedSystemTime);
  builder_.add_usedUserTime(usedUserTime);
  builder_.add_vsz(vsz);
  builder_.add_rss(rss);
  builder_.add_priorityLevel(priorityLevel);
  builder_.add_threadCount(threadCount);
  builder_.add_cpuUsage(cpuUsage);
  builder_.add_ppid(ppid);
  builder_.add_pid(pid);
  builder_.add_uid(uid);
  builder_.add_owner(owner);
  builder_.add_name(name);
  builder_.add_status(status);
  return builder_.Finish();
}

struct processInfoList : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<processInfo>> *list() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<processInfo>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* list */) &&
           verifier.Verify(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
};

struct processInfoListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<processInfo>>> list) { fbb_.AddOffset(4, list); }
  processInfoListBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  processInfoListBuilder &operator=(const processInfoListBuilder &);
  flatbuffers::Offset<processInfoList> Finish() {
    auto o = flatbuffers::Offset<processInfoList>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<processInfoList> CreateprocessInfoList(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<processInfo>>> list = 0) {
  processInfoListBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline const processInfoList *GetprocessInfoList(const void *buf) { return flatbuffers::GetRoot<processInfoList>(buf); }

inline bool VerifyprocessInfoListBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<processInfoList>(); }

inline void FinishprocessInfoListBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<processInfoList> root) { fbb.Finish(root); }

}  // namespace core
}  // namespace osmonitor
}  // namespace eolwral
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_PROCESSINFO_COM_EOLWRAL_OSMONITOR_CORE_H_
